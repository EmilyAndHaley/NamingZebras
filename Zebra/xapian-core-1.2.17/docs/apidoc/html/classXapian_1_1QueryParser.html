<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::QueryParser Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classXapian_1_1QueryParser-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::QueryParser Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query. ">Xapian::Query</a> object from a user query string.  
 <a href="classXapian_1_1QueryParser.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae96a58a8de9d219ca3214a5a66e0407e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">feature_flag</a> { <br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde">FLAG_BOOLEAN</a> = 1, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b">FLAG_PHRASE</a> = 2, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd">FLAG_LOVEHATE</a> = 4, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d">FLAG_BOOLEAN_ANY_CASE</a> = 8, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36">FLAG_WILDCARD</a> = 16, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0">FLAG_PURE_NOT</a> = 32, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7">FLAG_PARTIAL</a> = 64, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c">FLAG_SPELLING_CORRECTION</a> = 128, 
<br/>
&#160;&#160;<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f">FLAG_SYNONYM</a> = 256, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b">FLAG_AUTO_SYNONYMS</a> = 512, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b">FLAG_AUTO_MULTIWORD_SYNONYMS</a> = 1024 | FLAG_AUTO_SYNONYMS, 
<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a> = FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE
<br/>
 }</td></tr>
<tr class="memdesc:ae96a58a8de9d219ca3214a5a66e0407e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enum of feature flags.  <a href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">More...</a><br/></td></tr>
<tr class="separator:ae96a58a8de9d219ca3214a5a66e0407e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2959f7a1c5680f3fd1421d92445e220"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> </td></tr>
<tr class="memdesc:ae2959f7a1c5680f3fd1421d92445e220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stemming strategies, for use with <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy. ">set_stemming_strategy()</a>. <br/></td></tr>
<tr class="separator:ae2959f7a1c5680f3fd1421d92445e220"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a00d9afcf20b20cd9c8b3d22dd1bc82b7"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a00d9afcf20b20cd9c8b3d22dd1bc82b7">QueryParser</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor. <br/></td></tr>
<tr class="separator:a00d9afcf20b20cd9c8b3d22dd1bc82b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18adb637032c2149a0457f2f79f332a5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a18adb637032c2149a0457f2f79f332a5"></a>
<a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a18adb637032c2149a0457f2f79f332a5">operator=</a> (const <a class="el" href="classXapian_1_1QueryParser.html">QueryParser</a> &amp;o)</td></tr>
<tr class="memdesc:a18adb637032c2149a0457f2f79f332a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment. <br/></td></tr>
<tr class="separator:a18adb637032c2149a0457f2f79f332a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a724f1e26b785516c4c8cde78455f9cd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a724f1e26b785516c4c8cde78455f9cd5"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a724f1e26b785516c4c8cde78455f9cd5">QueryParser</a> ()</td></tr>
<tr class="memdesc:a724f1e26b785516c4c8cde78455f9cd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor. <br/></td></tr>
<tr class="separator:a724f1e26b785516c4c8cde78455f9cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69d48b819b0c6d6a29f86a756f91d047"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a69d48b819b0c6d6a29f86a756f91d047"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a69d48b819b0c6d6a29f86a756f91d047">~QueryParser</a> ()</td></tr>
<tr class="memdesc:a69d48b819b0c6d6a29f86a756f91d047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor. <br/></td></tr>
<tr class="separator:a69d48b819b0c6d6a29f86a756f91d047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2312c9865a58cc1149fe7cda9f0c2585"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2312c9865a58cc1149fe7cda9f0c2585">set_stemmer</a> (const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;stemmer)</td></tr>
<tr class="memdesc:a2312c9865a58cc1149fe7cda9f0c2585"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemmer.  <a href="#a2312c9865a58cc1149fe7cda9f0c2585">More...</a><br/></td></tr>
<tr class="separator:a2312c9865a58cc1149fe7cda9f0c2585"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd">set_stemming_strategy</a> (<a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a> strategy)</td></tr>
<tr class="memdesc:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stemming strategy.  <a href="#ac7dc3b55b6083bd3ff98fc8b2726c8fd">More...</a><br/></td></tr>
<tr class="separator:ac7dc3b55b6083bd3ff98fc8b2726c8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1046610676f72ba564108f0df5d77ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ab1046610676f72ba564108f0df5d77ab">set_stopper</a> (const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *stop=NULL)</td></tr>
<tr class="memdesc:ab1046610676f72ba564108f0df5d77ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the stopper.  <a href="#ab1046610676f72ba564108f0df5d77ab">More...</a><br/></td></tr>
<tr class="separator:ab1046610676f72ba564108f0df5d77ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2efe48be88c4872afec4bc963f417ea5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a2efe48be88c4872afec4bc963f417ea5">set_default_op</a> (<a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> default_op)</td></tr>
<tr class="memdesc:a2efe48be88c4872afec4bc963f417ea5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the default operator.  <a href="#a2efe48be88c4872afec4bc963f417ea5">More...</a><br/></td></tr>
<tr class="separator:a2efe48be88c4872afec4bc963f417ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6323a8aea7734e447de1ba7eab31c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a4a6323a8aea7734e447de1ba7eab31c1">get_default_op</a> () const </td></tr>
<tr class="memdesc:a4a6323a8aea7734e447de1ba7eab31c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current default operator.  <a href="#a4a6323a8aea7734e447de1ba7eab31c1">More...</a><br/></td></tr>
<tr class="separator:a4a6323a8aea7734e447de1ba7eab31c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a576d221ba746506e51d9ea596ecb2cf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6">set_database</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;db)</td></tr>
<tr class="memdesc:a576d221ba746506e51d9ea596ecb2cf6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the database being searched.  <a href="#a576d221ba746506e51d9ea596ecb2cf6">More...</a><br/></td></tr>
<tr class="separator:a576d221ba746506e51d9ea596ecb2cf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7651d48cdc661c0605c475925170cc71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a7651d48cdc661c0605c475925170cc71">set_max_wildcard_expansion</a> (<a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> limit)</td></tr>
<tr class="memdesc:a7651d48cdc661c0605c475925170cc71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specify the maximum expansion of a wildcard term.  <a href="#a7651d48cdc661c0605c475925170cc71">More...</a><br/></td></tr>
<tr class="separator:a7651d48cdc661c0605c475925170cc71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1Query.html">Query</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2">parse_query</a> (const std::string &amp;query_string, unsigned flags=<a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a>, const std::string &amp;default_prefix=std::string())</td></tr>
<tr class="memdesc:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a query.  <a href="#a73d32cc7f862ab2e3fdd7da61f352fb2">More...</a><br/></td></tr>
<tr class="separator:a73d32cc7f862ab2e3fdd7da61f352fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4829ddcaa0582ff94d1066870a18c97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97">add_prefix</a> (const std::string &amp;field, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:ad4829ddcaa0582ff94d1066870a18c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a probabilistic term prefix.  <a href="#ad4829ddcaa0582ff94d1066870a18c97">More...</a><br/></td></tr>
<tr class="separator:ad4829ddcaa0582ff94d1066870a18c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67d25f9297bb98c2101a03ff3d60cf30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a67d25f9297bb98c2101a03ff3d60cf30">add_boolean_prefix</a> (const std::string &amp;field, const std::string &amp;prefix, bool exclusive)</td></tr>
<tr class="memdesc:a67d25f9297bb98c2101a03ff3d60cf30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query.  <a href="#a67d25f9297bb98c2101a03ff3d60cf30">More...</a><br/></td></tr>
<tr class="separator:a67d25f9297bb98c2101a03ff3d60cf30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ff03cd3fe1fa2b6e07fc347bee3590"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a57ff03cd3fe1fa2b6e07fc347bee3590"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a57ff03cd3fe1fa2b6e07fc347bee3590">stoplist_begin</a> () const </td></tr>
<tr class="memdesc:a57ff03cd3fe1fa2b6e07fc347bee3590"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over terms omitted from the query as stopwords. <br/></td></tr>
<tr class="separator:a57ff03cd3fe1fa2b6e07fc347bee3590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2088e54f557e2d608247c5237a1bc3b"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa2088e54f557e2d608247c5237a1bc3b"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#aa2088e54f557e2d608247c5237a1bc3b">unstem_begin</a> (const std::string &amp;term) const </td></tr>
<tr class="memdesc:aa2088e54f557e2d608247c5237a1bc3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over unstemmed forms of the given (stemmed) term used in the query. <br/></td></tr>
<tr class="separator:aa2088e54f557e2d608247c5237a1bc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8583a9f044f2eb33859b442a8aea76"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8f8583a9f044f2eb33859b442a8aea76"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a8f8583a9f044f2eb33859b442a8aea76">add_valuerangeprocessor</a> (<a class="el" href="structXapian_1_1ValueRangeProcessor.html">Xapian::ValueRangeProcessor</a> *vrproc)</td></tr>
<tr class="memdesc:a8f8583a9f044f2eb33859b442a8aea76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Register a <a class="el" href="structXapian_1_1ValueRangeProcessor.html" title="Base class for value range processors. ">ValueRangeProcessor</a>. <br/></td></tr>
<tr class="separator:a8f8583a9f044f2eb33859b442a8aea76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e59c760a0a4edacb437621ac66be25a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a">get_corrected_query_string</a> () const </td></tr>
<tr class="memdesc:a0e59c760a0a4edacb437621ac66be25a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the spelling-corrected query string.  <a href="#a0e59c760a0a4edacb437621ac66be25a">More...</a><br/></td></tr>
<tr class="separator:a0e59c760a0a4edacb437621ac66be25a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89f9d15f38538a07497fdfc8658852b2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a89f9d15f38538a07497fdfc8658852b2"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1QueryParser.html#a89f9d15f38538a07497fdfc8658852b2">get_description</a> () const </td></tr>
<tr class="memdesc:a89f9d15f38538a07497fdfc8658852b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br/></td></tr>
<tr class="separator:a89f9d15f38538a07497fdfc8658852b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Build a <a class="el" href="classXapian_1_1Query.html" title="Class representing a query. ">Xapian::Query</a> object from a user query string. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407e">Xapian::QueryParser::feature_flag</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enum of feature flags. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaffc56acef4c5b0da425d4ea74b7affde"></a>FLAG_BOOLEAN</em>&nbsp;</td><td class="fielddoc">
<p>Support AND, OR, etc and bracketed subexpressions. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ead7e3ef99f48e26f40836a2e98ac86e6b"></a>FLAG_PHRASE</em>&nbsp;</td><td class="fielddoc">
<p>Support quoted phrases. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea0c7c618a79df1201ef342951450447cd"></a>FLAG_LOVEHATE</em>&nbsp;</td><td class="fielddoc">
<p>Support + and -. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea9046353051e08dd0149b4fced176ed3d"></a>FLAG_BOOLEAN_ANY_CASE</em>&nbsp;</td><td class="fielddoc">
<p>Support AND, OR, etc even if they aren't in ALLCAPS. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea99e75d48aca2ebbf477572d855c82e36"></a>FLAG_WILDCARD</em>&nbsp;</td><td class="fielddoc">
<p>Support right truncation (e.g. </p>
<p>Xap*). </p>
<pre class="fragment">   Currently you can't use wildcards with boolean filter prefixes,
   or in a phrase (either an explicitly quoted one, or one implicitly
   generated by hyphens or other punctuation).

   NB: You need to tell the QueryParser object which database to
   expand wildcards from by calling set_database.</pre> </td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eacafc7c8cf7c90adac0fc07d02125aed0"></a>FLAG_PURE_NOT</em>&nbsp;</td><td class="fielddoc">
<p>Allow queries such as 'NOT apples'. </p>
<p>These require the use of a list of all documents in the database which is potentially expensive, so this feature isn't enabled by default. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eae0b632c2f797fc7ae53c444f104072c7"></a>FLAG_PARTIAL</em>&nbsp;</td><td class="fielddoc">
<p>Enable partial matching. </p>
<p>Partial matching causes the parser to treat the query as a "partially entered" search. This will automatically treat the final word as a wildcarded match, unless it is followed by whitespace, to produce more stable results from interactive searches.</p>
<p>Currently FLAG_PARTIAL doesn't do anything if the final word in the query has a boolean filter prefix, or if it is in a phrase (either an explicitly quoted one, or one implicitly generated by hyphens or other punctuation). It also doesn't do anything if if the final word is part of a value range.</p>
<p>NB: You need to tell the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string. ">QueryParser</a> object which database to expand wildcards from by calling set_database. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaacef09c368bdafe64debabe112f1024c"></a>FLAG_SPELLING_CORRECTION</em>&nbsp;</td><td class="fielddoc">
<p>Enable spelling correction. </p>
<p>For each word in the query which doesn't exist as a term in the database, <a class="el" href="classXapian_1_1Database.html#a86b944dece96d7ada2446ae8952ee3a2" title="Suggest a spelling correction. ">Database::get_spelling_suggestion()</a> will be called and if a suggestion is returned, a corrected version of the query string will be built up which can be read using <a class="el" href="classXapian_1_1QueryParser.html#a0e59c760a0a4edacb437621ac66be25a" title="Get the spelling-corrected query string. ">QueryParser::get_corrected_query_string()</a>. The query returned is based on the uncorrected query string however - if you want a parsed query based on the corrected query string, you must call <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">QueryParser::parse_query()</a> again.</p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407eaa139c20751d70cc6d19d7541160d7d3f"></a>FLAG_SYNONYM</em>&nbsp;</td><td class="fielddoc">
<p>Enable synonym operator '~'. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea15716c0dcfe839e7d9a8e8337bbed16b"></a>FLAG_AUTO_SYNONYMS</em>&nbsp;</td><td class="fielddoc">
<p>Enable automatic use of synonyms for single terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea175afae857d6aa6a4aecccfe8793be1b"></a>FLAG_AUTO_MULTIWORD_SYNONYMS</em>&nbsp;</td><td class="fielddoc">
<p>Enable automatic use of synonyms for single terms and groups of terms. </p>
<p>NB: You must also call <a class="el" href="classXapian_1_1QueryParser.html#a576d221ba746506e51d9ea596ecb2cf6" title="Specify the database being searched. ">set_database()</a> for this to work. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a"></a>FLAG_DEFAULT</em>&nbsp;</td><td class="fielddoc">
<p>The default flags. </p>
<p>Used if you don't explicitly pass any to <em><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">parse_query()</a></em>. The default flags are FLAG_PHRASE|FLAG_BOOLEAN|FLAG_LOVEHATE.</p>
<p>Added in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.0.11. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67d25f9297bb98c2101a03ff3d60cf30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_boolean_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>exclusive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in the free text query. </p>
<p>For example:</p>
<div class="fragment"><div class="line">*  qp.add_boolean_prefix(<span class="stringliteral">&quot;site&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>);</div>
<div class="line">*  </div>
</div><!-- fragment --><p>This allows the user to restrict a search with site:xapian.org which will be converted to Hxapian.org combined with any probabilistic query with <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac657f344bf26128ab7bf8fe25410b102" title="As AND, but use only weights from left subquery. ">Xapian::Query::OP_FILTER</a></code>.</p>
<p>If multiple boolean filters are specified in a query for the same prefix, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied. ">Xapian::Query::OP_OR</a></code> operator. Then, if there are boolean filters for different prefixes, they will be combined with the <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bab99aad2dfc85eccc56163bc65eb0fdda" title="Return iff both subqueries are satisfied. ">Xapian::Query::OP_AND</a></code> operator.</p>
<p>Multiple fields can be mapped to the same prefix (so for example you can make site: and domain: aliases for each other). Instances of fields with different aliases but the same prefix will still be combined with the OR operator.</p>
<p>For example, if "site" and "domain" map to "H", but author maps to "A", a search for "site:foo domain:bar author:Fred" will map to "(Hfoo OR Hbar) AND Afred".</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied. ">Xapian::Query::OP_OR</a></code>.</p>
<p>Calling this method with an empty string for <em>field</em> will cause a <code><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></code>.</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix. ">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a67d25f9297bb98c2101a03ff3d60cf30" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way. ">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
    <tr><td class="paramname">exclusive</td><td>If true, each document can have at most one term with this prefix, so multiple filters with this prefix should be combined with OP_OR. If false, each document can have multiple terms with this prefix, so multiple filters should be combined with OP_AND, like happens with filters with different prefixes. [default: true] </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad4829ddcaa0582ff94d1066870a18c97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::add_prefix </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>field</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a probabilistic term prefix. </p>
<p>For example:</p>
<div class="fragment"><div class="line">*  qp.add_prefix(<span class="stringliteral">&quot;author&quot;</span>, <span class="stringliteral">&quot;A&quot;</span>);</div>
<div class="line">*  </div>
</div><!-- fragment --><p>This allows the user to search for author:Orwell which will be converted to a search for the term "Aorwell".</p>
<p>Multiple fields can be mapped to the same prefix. For example, you can make title: and subject: aliases for each other.</p>
<p>As of 1.0.4, you can call this method multiple times with the same value of field to allow a single field to be mapped to multiple prefixes. Multiple terms being generated for such a field, and combined with <code><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied. ">Xapian::Query::OP_OR</a></code>.</p>
<p>If any prefixes are specified for the empty field name (i.e. you call this method with an empty string as the first parameter) these prefixes will be used for terms without a field specifier. If you do this and also specify the <code>default_prefix</code> parameter to <code><a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">parse_query()</a></code>, then the <code>default_prefix</code> parameter will override.</p>
<p>If the prefix parameter is empty, then "field:word" will produce the term "word" (and this can be one of several prefixes for a particular field, or for terms without a field specifier).</p>
<p>If you call <code><a class="el" href="classXapian_1_1QueryParser.html#ad4829ddcaa0582ff94d1066870a18c97" title="Add a probabilistic term prefix. ">add_prefix()</a></code> and <code><a class="el" href="classXapian_1_1QueryParser.html#a67d25f9297bb98c2101a03ff3d60cf30" title="Add a boolean term prefix allowing the user to restrict a search with a boolean filter specified in t...">add_boolean_prefix()</a></code> for the same value of <em>field</em>, a <code><a class="el" href="classXapian_1_1InvalidOperationError.html" title="InvalidOperationError indicates the API was used in an invalid way. ">Xapian::InvalidOperationError</a></code> exception will be thrown.</p>
<p>In 1.0.3 and earlier, subsequent calls to this method with the same value of <em>field</em> had no effect.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">field</td><td>The user visible field name </td></tr>
    <tr><td class="paramname">prefix</td><td>The term prefix to map this to </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0e59c760a0a4edacb437621ac66be25a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Xapian::QueryParser::get_corrected_query_string </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the spelling-corrected query string. </p>
<p>This will only be set if FLAG_SPELLING_CORRECTION is specified when <a class="el" href="classXapian_1_1QueryParser.html#a73d32cc7f862ab2e3fdd7da61f352fb2" title="Parse a query. ">QueryParser::parse_query()</a> was last called.</p>
<p>If there were no corrections, an empty string is returned. </p>

</div>
</div>
<a class="anchor" id="a4a6323a8aea7734e447de1ba7eab31c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a> Xapian::QueryParser::get_default_op </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current default operator. </p>

</div>
</div>
<a class="anchor" id="a73d32cc7f862ab2e3fdd7da61f352fb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1Query.html">Query</a> Xapian::QueryParser::parse_query </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>query_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="classXapian_1_1QueryParser.html#ae96a58a8de9d219ca3214a5a66e0407ea4e4a5c38e629300d01219456add0ea4a">FLAG_DEFAULT</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>default_prefix</em> = <code>std::string()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse a query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query_string</td><td>A free-text query as entered by a user </td></tr>
    <tr><td class="paramname">flags</td><td>Zero or more Query::feature_flag specifying what features the <a class="el" href="classXapian_1_1QueryParser.html" title="Build a Xapian::Query object from a user query string. ">QueryParser</a> should support. Combine multiple values with bitwise-or (|) (default FLAG_DEFAULT). </td></tr>
    <tr><td class="paramname">default_prefix</td><td>The default term prefix to use (default none). For example, you can pass "A" when parsing an "Author" field.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">If</td><td>the query string can't be parsed, then <a class="el" href="classXapian_1_1QueryParserError.html" title="Indicates a query string can&#39;t be parsed. ">Xapian::QueryParserError</a> is thrown. You can get an English error message to report to the user by catching it and calling get_msg() on the caught exception. The current possible values (in case you want to translate them) are: <pre class="fragment"> @li Unknown range operation
 @li parse error
 @li Syntax: &amp;lt;expression&amp;gt; AND &amp;lt;expression&amp;gt;
 @li Syntax: &amp;lt;expression&amp;gt; AND NOT &amp;lt;expression&amp;gt;
 @li Syntax: &amp;lt;expression&amp;gt; NOT &amp;lt;expression&amp;gt;
 @li Syntax: &amp;lt;expression&amp;gt; OR &amp;lt;expression&amp;gt;
 @li Syntax: &amp;lt;expression&amp;gt; XOR &amp;lt;expression&amp;gt;</pre> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a576d221ba746506e51d9ea596ecb2cf6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_database </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>db</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the database being searched. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">db</td><td>The database to use for wildcard expansion (FLAG_WILDCARD and FLAG_PARTIAL), spelling correction (FLAG_SPELLING_CORRECTION), and synonyms (FLAG_SYNONYM, FLAG_AUTO_SYNONYMS, and FLAG_AUTO_MULTIWORD_SYNONYMS). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2efe48be88c4872afec4bc963f417ea5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_default_op </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100b">Query::op</a>&#160;</td>
          <td class="paramname"><em>default_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the default operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">default_op</td><td>The operator to use to combine non-filter query items when no explicit operator is used.</td></tr>
  </table>
  </dd>
</dl>
<p>The most useful values for this are OP_OR (the default) and OP_AND. OP_NEAR and OP_PHRASE can also be useful.</p>
<p>So for example, 'weather forecast' is parsed as if it were 'weather OR forecast' by default. </p>

</div>
</div>
<a class="anchor" id="a7651d48cdc661c0605c475925170cc71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_max_wildcard_expansion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specify the maximum expansion of a wildcard term. </p>
<p>Note: you must also set FLAG_WILDCARD for wildcard expansion to happen.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">limit</td><td>The maximum number of terms each wildcard in the query can expand to, or 0 for no limit (which is the default). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2312c9865a58cc1149fe7cda9f0c2585"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stem.html">Xapian::Stem</a> &amp;&#160;</td>
          <td class="paramname"><em>stemmer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemmer. </p>
<p>This sets the stemming algorithm which will be used by the query parser. Note that the stemming algorithm will only be used according to the stemming strategy set by <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy. ">set_stemming_strategy()</a>, which defaults to STEM_NONE. Therefore, to use a stemming algorithm, you will also need to call <a class="el" href="classXapian_1_1QueryParser.html#ac7dc3b55b6083bd3ff98fc8b2726c8fd" title="Set the stemming strategy. ">set_stemming_strategy()</a> with a value other than STEM_NONE.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stemmer</td><td>The <a class="el" href="classXapian_1_1Stem.html" title="Class representing a stemming algorithm. ">Xapian::Stem</a> object to set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac7dc3b55b6083bd3ff98fc8b2726c8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stemming_strategy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1QueryParser.html#ae2959f7a1c5680f3fd1421d92445e220">stem_strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stemming strategy. </p>
<p>This controls how the query parser will apply the stemming algorithm. Note that the stemming algorithm is only applied to words in probabilistic fields - boolean filter terms are never stemmed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">strategy</td><td>The strategy to use - possible values are:<ul>
<li>STEM_NONE: Don't perform any stemming. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> &lt;= 1.3.0)</li>
<li>STEM_SOME: Search for stemmed forms of terms except for those which start with a capital letter, or are followed by certain characters (currently: (/@&lt;&gt;=*[{" ), or are used with operators which need positional information. Stemmed terms are prefixed with 'Z'. (default in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> &gt;= 1.3.1)</li>
<li>STEM_ALL: Search for stemmed forms of all words (note: no 'Z' prefix is added).</li>
<li>STEM_ALL_Z: Search for stemmed forms of all words (note: 'Z' prefix is added). (new in <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> 1.2.11 and 1.3.1) </li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab1046610676f72ba564108f0df5d77ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::QueryParser::set_stopper </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Stopper.html">Stopper</a> *&#160;</td>
          <td class="paramname"><em>stop</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the stopper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stop</td><td>The <a class="el" href="classXapian_1_1Stopper.html" title="Base class for stop-word decision functor. ">Stopper</a> object to set (default NULL, which means no stopwords). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="queryparser_8h.html">queryparser.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.2.17).<br>
Generated on Wed Jan 29 2014 by
<a href="http://www.doxygen.org/">Doxygen 1.8.5</a>.
</small></address>
</body>
</html>

<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<html>
<head>
<title>Xapian: API Documentation: Xapian::Enquire Class Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head>
<body bgcolor="#ffffff">
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceXapian.html">Xapian</a></li><li class="navelem"><a class="el" href="classXapian_1_1Enquire.html">Enquire</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classXapian_1_1Enquire-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Xapian::Enquire Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This class provides an interface to the information retrieval system for the purpose of searching.  
 <a href="classXapian_1_1Enquire.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac451dc68045ec4b0d26f5b2a42eae2a9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac451dc68045ec4b0d26f5b2a42eae2a9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ac451dc68045ec4b0d26f5b2a42eae2a9">Enquire</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>
<tr class="memdesc:ac451dc68045ec4b0d26f5b2a42eae2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copying is allowed (and is cheap). <br/></td></tr>
<tr class="separator:ac451dc68045ec4b0d26f5b2a42eae2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c067ef5b6397ab064d09884efc06cbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0c067ef5b6397ab064d09884efc06cbe"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a0c067ef5b6397ab064d09884efc06cbe">operator=</a> (const <a class="el" href="classXapian_1_1Enquire.html">Enquire</a> &amp;other)</td></tr>
<tr class="memdesc:a0c067ef5b6397ab064d09884efc06cbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment is allowed (and is cheap). <br/></td></tr>
<tr class="separator:a0c067ef5b6397ab064d09884efc06cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9dcba0c6d10dd8dd6ae59e087f84799"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#af9dcba0c6d10dd8dd6ae59e087f84799">Enquire</a> (const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;database, <a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *errorhandler_=0)</td></tr>
<tr class="memdesc:af9dcba0c6d10dd8dd6ae59e087f84799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object.  <a href="#af9dcba0c6d10dd8dd6ae59e087f84799">More...</a><br/></td></tr>
<tr class="separator:af9dcba0c6d10dd8dd6ae59e087f84799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808479faae76453f34a24881805e75b9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a808479faae76453f34a24881805e75b9"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a808479faae76453f34a24881805e75b9">~Enquire</a> ()</td></tr>
<tr class="memdesc:a808479faae76453f34a24881805e75b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object. <br/></td></tr>
<tr class="separator:a808479faae76453f34a24881805e75b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1148d960120662e5543e2a2b12620318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a1148d960120662e5543e2a2b12620318">set_query</a> (const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;query, <a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> qlen=0)</td></tr>
<tr class="memdesc:a1148d960120662e5543e2a2b12620318"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the query to run.  <a href="#a1148d960120662e5543e2a2b12620318">More...</a><br/></td></tr>
<tr class="separator:a1148d960120662e5543e2a2b12620318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add445bf19315638cccbb6418e2ae0d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#add445bf19315638cccbb6418e2ae0d42">get_query</a> () const </td></tr>
<tr class="memdesc:add445bf19315638cccbb6418e2ae0d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the query which has been set.  <a href="#add445bf19315638cccbb6418e2ae0d42">More...</a><br/></td></tr>
<tr class="separator:add445bf19315638cccbb6418e2ae0d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b54489c53d26a98d3fde3f1d3aa14f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a43b54489c53d26a98d3fde3f1d3aa14f">add_matchspy</a> (<a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *spy)</td></tr>
<tr class="memdesc:a43b54489c53d26a98d3fde3f1d3aa14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a matchspy.  <a href="#a43b54489c53d26a98d3fde3f1d3aa14f">More...</a><br/></td></tr>
<tr class="separator:a43b54489c53d26a98d3fde3f1d3aa14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb73406e3e7749a9e66ebc96ebd13f3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1bb73406e3e7749a9e66ebc96ebd13f3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a1bb73406e3e7749a9e66ebc96ebd13f3">clear_matchspies</a> ()</td></tr>
<tr class="memdesc:a1bb73406e3e7749a9e66ebc96ebd13f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all the matchspies. <br/></td></tr>
<tr class="separator:a1bb73406e3e7749a9e66ebc96ebd13f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5c72e6f34c5c2da5f0b8c79736704ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ad5c72e6f34c5c2da5f0b8c79736704ab">set_weighting_scheme</a> (const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;weight_)</td></tr>
<tr class="memdesc:ad5c72e6f34c5c2da5f0b8c79736704ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the weighting scheme to use for queries.  <a href="#ad5c72e6f34c5c2da5f0b8c79736704ab">More...</a><br/></td></tr>
<tr class="separator:ad5c72e6f34c5c2da5f0b8c79736704ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117ee547f5908e952e2e72d5a986d3bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a117ee547f5908e952e2e72d5a986d3bb">set_collapse_key</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> collapse_key, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> collapse_max=1)</td></tr>
<tr class="memdesc:a117ee547f5908e952e2e72d5a986d3bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the collapse key to use for queries.  <a href="#a117ee547f5908e952e2e72d5a986d3bb">More...</a><br/></td></tr>
<tr class="separator:a117ee547f5908e952e2e72d5a986d3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbf7ff734ff6adcb301e493f6eed803b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#abbf7ff734ff6adcb301e493f6eed803b">set_docid_order</a> (docid_order order)</td></tr>
<tr class="memdesc:abbf7ff734ff6adcb301e493f6eed803b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>.  <a href="#abbf7ff734ff6adcb301e493f6eed803b">More...</a><br/></td></tr>
<tr class="separator:abbf7ff734ff6adcb301e493f6eed803b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adadaa8401e40ab4cec090bc1541a11b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#adadaa8401e40ab4cec090bc1541a11b7">set_cutoff</a> (<a class="el" href="namespaceXapian.html#a22ea0a80c58a2047dd929621b75ed9a2">Xapian::percent</a> percent_cutoff, <a class="el" href="namespaceXapian.html#acac12803afc9e24ee5141c119acb8884">Xapian::weight</a> weight_cutoff=0)</td></tr>
<tr class="memdesc:adadaa8401e40ab4cec090bc1541a11b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the percentage and/or weight cutoffs.  <a href="#adadaa8401e40ab4cec090bc1541a11b7">More...</a><br/></td></tr>
<tr class="separator:adadaa8401e40ab4cec090bc1541a11b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80a33a28791c05167204706c1a9d986b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b">set_sort_by_relevance</a> ()</td></tr>
<tr class="memdesc:a80a33a28791c05167204706c1a9d986b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance only.  <a href="#a80a33a28791c05167204706c1a9d986b">More...</a><br/></td></tr>
<tr class="separator:a80a33a28791c05167204706c1a9d986b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab10384fabd51eebd8174f916563e3f7a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ab10384fabd51eebd8174f916563e3f7a">set_sort_by_value</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:ab10384fabd51eebd8174f916563e3f7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by value only.  <a href="#ab10384fabd51eebd8174f916563e3f7a">More...</a><br/></td></tr>
<tr class="separator:ab10384fabd51eebd8174f916563e3f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcb7086d8633fc035c6e5d094e45d39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a0bcb7086d8633fc035c6e5d094e45d39">set_sort_by_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:a0bcb7086d8633fc035c6e5d094e45d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by key generated from values only.  <a href="#a0bcb7086d8633fc035c6e5d094e45d39">More...</a><br/></td></tr>
<tr class="separator:a0bcb7086d8633fc035c6e5d094e45d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa921b3c9386fbe2ddfd7dbbf130f9391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#aa921b3c9386fbe2ddfd7dbbf130f9391">set_sort_by_value_then_relevance</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:aa921b3c9386fbe2ddfd7dbbf130f9391"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by value, then by relevance for documents with the same value.  <a href="#aa921b3c9386fbe2ddfd7dbbf130f9391">More...</a><br/></td></tr>
<tr class="separator:aa921b3c9386fbe2ddfd7dbbf130f9391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a562beac4843f310dbdc61fdd33209be4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a562beac4843f310dbdc61fdd33209be4">set_sort_by_key_then_relevance</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:a562beac4843f310dbdc61fdd33209be4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by keys generated from values, then by relevance for documents with identical keys.  <a href="#a562beac4843f310dbdc61fdd33209be4">More...</a><br/></td></tr>
<tr class="separator:a562beac4843f310dbdc61fdd33209be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a495760d5edc479385b14b463affbff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a5a495760d5edc479385b14b463affbff">set_sort_by_relevance_then_value</a> (<a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a> sort_key, bool reverse)</td></tr>
<tr class="memdesc:a5a495760d5edc479385b14b463affbff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance then value.  <a href="#a5a495760d5edc479385b14b463affbff">More...</a><br/></td></tr>
<tr class="separator:a5a495760d5edc479385b14b463affbff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac64b07e06a24519baf1c495d0edcd0c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ac64b07e06a24519baf1c495d0edcd0c3">set_sort_by_relevance_then_key</a> (<a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *sorter, bool reverse)</td></tr>
<tr class="memdesc:ac64b07e06a24519baf1c495d0edcd0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the sorting to be by relevance, then by keys generated from values.  <a href="#ac64b07e06a24519baf1c495d0edcd0c3">More...</a><br/></td></tr>
<tr class="separator:ac64b07e06a24519baf1c495d0edcd0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac04aa26eff82db9fd810b8125a31ee55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ac04aa26eff82db9fd810b8125a31ee55">get_eset</a> (<a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags=0, double k=1.0, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider=0) const </td></tr>
<tr class="memdesc:ac04aa26eff82db9fd810b8125a31ee55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#ac04aa26eff82db9fd810b8125a31ee55">More...</a><br/></td></tr>
<tr class="separator:ac04aa26eff82db9fd810b8125a31ee55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af73e3672a3f1077309fbc99ef2db5412"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#af73e3672a3f1077309fbc99ef2db5412">get_eset</a> (<a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider) const </td></tr>
<tr class="memdesc:af73e3672a3f1077309fbc99ef2db5412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#af73e3672a3f1077309fbc99ef2db5412">More...</a><br/></td></tr>
<tr class="separator:af73e3672a3f1077309fbc99ef2db5412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0b50863720f25f8a026bee73913798b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1ESet.html">ESet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#aa0b50863720f25f8a026bee73913798b">get_eset</a> (<a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;omrset, int flags, double k, const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *edecider, <a class="el" href="namespaceXapian.html#acac12803afc9e24ee5141c119acb8884">Xapian::weight</a> min_wt) const </td></tr>
<tr class="memdesc:aa0b50863720f25f8a026bee73913798b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the expand set for the given rset.  <a href="#aa0b50863720f25f8a026bee73913798b">More...</a><br/></td></tr>
<tr class="separator:aa0b50863720f25f8a026bee73913798b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda4181ccd15beb52c39f5e24adbb25b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b">get_matching_terms_begin</a> (<a class="el" href="namespaceXapian.html#a8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a> did) const </td></tr>
<tr class="memdesc:adda4181ccd15beb52c39f5e24adbb25b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get terms which match a given document, by document id.  <a href="#adda4181ccd15beb52c39f5e24adbb25b">More...</a><br/></td></tr>
<tr class="separator:adda4181ccd15beb52c39f5e24adbb25b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a27b926405ef71ab138fa656dab0bd4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6a27b926405ef71ab138fa656dab0bd4"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a6a27b926405ef71ab138fa656dab0bd4">get_matching_terms_end</a> (<a class="el" href="namespaceXapian.html#a8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a>) const </td></tr>
<tr class="memdesc:a6a27b926405ef71ab138fa656dab0bd4"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id. ">get_matching_terms_begin()</a> <br/></td></tr>
<tr class="separator:a6a27b926405ef71ab138fa656dab0bd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d531a494be857ae09c831480ff651d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a4d531a494be857ae09c831480ff651d7">get_matching_terms_begin</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;it) const </td></tr>
<tr class="memdesc:a4d531a494be857ae09c831480ff651d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get terms which match a given document, by match set item.  <a href="#a4d531a494be857ae09c831480ff651d7">More...</a><br/></td></tr>
<tr class="separator:a4d531a494be857ae09c831480ff651d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a619e5a4f3597ed800e8f11190a5b7fe0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a619e5a4f3597ed800e8f11190a5b7fe0"></a>
<a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a619e5a4f3597ed800e8f11190a5b7fe0">get_matching_terms_end</a> (const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;) const </td></tr>
<tr class="memdesc:a619e5a4f3597ed800e8f11190a5b7fe0"><td class="mdescLeft">&#160;</td><td class="mdescRight">End iterator corresponding to <a class="el" href="classXapian_1_1Enquire.html#adda4181ccd15beb52c39f5e24adbb25b" title="Get terms which match a given document, by document id. ">get_matching_terms_begin()</a> <br/></td></tr>
<tr class="separator:a619e5a4f3597ed800e8f11190a5b7fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a980eb2599afdf52ae78788849c9921"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4a980eb2599afdf52ae78788849c9921"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a4a980eb2599afdf52ae78788849c9921">get_description</a> () const </td></tr>
<tr class="memdesc:a4a980eb2599afdf52ae78788849c9921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a string describing this object. <br/></td></tr>
<tr class="separator:a4a980eb2599afdf52ae78788849c9921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a1fc149dc9c58bc962ce9e4372c863185"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#a1fc149dc9c58bc962ce9e4372c863185">get_mset</a> (<a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> checkatleast, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *matchspy) const </td></tr>
<tr class="memdesc:a1fc149dc9c58bc962ce9e4372c863185"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#a1fc149dc9c58bc962ce9e4372c863185">More...</a><br/></td></tr>
<tr class="separator:a1fc149dc9c58bc962ce9e4372c863185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedb5fb761acc0bb2249bec375883a093"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#aedb5fb761acc0bb2249bec375883a093">get_mset</a> (<a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> checkatleast=0, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset=0, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>
<tr class="memdesc:aedb5fb761acc0bb2249bec375883a093"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#aedb5fb761acc0bb2249bec375883a093">More...</a><br/></td></tr>
<tr class="separator:aedb5fb761acc0bb2249bec375883a093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53aba9cb5b62d14dce5395f568c050f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXapian_1_1MSet.html">MSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classXapian_1_1Enquire.html#ad53aba9cb5b62d14dce5395f568c050f">get_mset</a> (<a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> first, <a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a> maxitems, const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *omrset, const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *mdecider=0) const </td></tr>
<tr class="memdesc:ad53aba9cb5b62d14dce5395f568c050f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get (a portion of) the match set for the current query.  <a href="#ad53aba9cb5b62d14dce5395f568c050f">More...</a><br/></td></tr>
<tr class="separator:ad53aba9cb5b62d14dce5395f568c050f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides an interface to the information retrieval system for the purpose of searching. </p>
<p>Databases are usually opened lazily, so exceptions may not be thrown where you would expect them to be. You should catch <a class="el" href="classXapian_1_1Error.html" title="All exceptions thrown by Xapian are subclasses of Xapian::Error. ">Xapian::Error</a> exceptions when calling any method in <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a>.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>will be thrown if an invalid argument is supplied, for example, an unknown database type. </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="af9dcba0c6d10dd8dd6ae59e087f84799"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Xapian::Enquire::Enquire </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Database.html">Database</a> &amp;&#160;</td>
          <td class="paramname"><em>database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classXapian_1_1ErrorHandler.html">ErrorHandler</a> *&#160;</td>
          <td class="paramname"><em>errorhandler_</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object. </p>
<p>This specification cannot be changed once the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> is opened: you must create a new <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object to access a different database, or set of databases.</p>
<p>The database supplied must have been initialised (ie, must not be the result of calling the <a class="el" href="classXapian_1_1Database.html#a24f8197f3ac8bfd8c2526e0b8dff4ff7" title="Create a Database with no databases in. ">Database::Database()</a> constructor). If you need to handle a situation where you have no index gracefully, a database created with <a class="el" href="namespaceXapian_1_1InMemory.html#ab4b5fcea687b7b2eb81c5ecc58673d72" title="Construct a WritableDatabase object for a new, empty InMemory database. ">InMemory::open()</a> can be passed here, which represents a completely empty database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">database</td><td>Specification of the database or databases to use. </td></tr>
    <tr><td class="paramname">errorhandler_</td><td>A pointer to the error handler to use. Ownership of the object pointed to is not assumed by the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object - the user should delete the <a class="el" href="classXapian_1_1ErrorHandler.html" title="Decide if a Xapian::Error exception should be ignored. ">Xapian::ErrorHandler</a> object after the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Xapian::Enquire</a> object is deleted. To use no error handler, this parameter should be 0.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>will be thrown if an empty <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases. ">Database</a> object is supplied. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a43b54489c53d26a98d3fde3f1d3aa14f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::add_matchspy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1MatchSpy.html">MatchSpy</a> *&#160;</td>
          <td class="paramname"><em>spy</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a matchspy. </p>
<p>This matchspy will be called with some of the documents which match the query, during the match process. Exactly which of the matching documents are passed to it depends on exactly when certain optimisations occur during the match process, but it can be controlled to some extent by setting the <em>checkatleast</em> parameter to <em><a class="el" href="classXapian_1_1Enquire.html#a1fc149dc9c58bc962ce9e4372c863185" title="Get (a portion of) the match set for the current query. ">get_mset()</a></em>.</p>
<p>In particular, if there are enough matching documents, at least the number specified by <em>checkatleast</em> will be passed to the matchspy. This means that you can force the matchspy to be shown all matching documents by setting <em>checkatleast</em> to the number of documents in the database.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spy</td><td>The <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies. ">MatchSpy</a> subclass to add. The caller must ensure that this remains valid while the <a class="el" href="classXapian_1_1Enquire.html" title="This class provides an interface to the information retrieval system for the purpose of searching...">Enquire</a> object remains active, or until <em><a class="el" href="classXapian_1_1Enquire.html#a1bb73406e3e7749a9e66ebc96ebd13f3" title="Remove all the matchspies. ">clear_matchspies()</a></em> is called. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac04aa26eff82db9fd810b8125a31ee55"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">flags</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li>
<li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li>
</ul>
</td></tr>
    <tr><td class="paramname">k</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af73e3672a3f1077309fbc99ef2db5412"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa0b50863720f25f8a026bee73913798b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1ESet.html">ESet</a> Xapian::Enquire::get_eset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> &amp;&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1ExpandDecider.html">Xapian::ExpandDecider</a> *&#160;</td>
          <td class="paramname"><em>edecider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#acac12803afc9e24ee5141c119acb8884">Xapian::weight</a>&#160;</td>
          <td class="paramname"><em>min_wt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the expand set for the given rset. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the expand operation. </td></tr>
    <tr><td class="paramname">flags</td><td>zero or more of these values |-ed together:<ul>
<li>Xapian::Enquire::INCLUDE_QUERY_TERMS query terms may be returned from expand</li>
<li>Xapian::Enquire::USE_EXACT_TERMFREQ for multi dbs, calculate the exact termfreq; otherwise an approximation is used which can greatly improve efficiency, but still returns good results. </li>
</ul>
</td></tr>
    <tr><td class="paramname">k</td><td>the parameter k in the query expansion algorithm (default is 1.0) </td></tr>
    <tr><td class="paramname">edecider</td><td>a decision functor to use to decide whether a given term should be put in the <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a></td></tr>
    <tr><td class="paramname">min_wt</td><td>the minimum weight for included terms</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An <a class="el" href="classXapian_1_1ESet.html" title="Class representing an ordered set of expand terms (an ESet). ">ESet</a> object containing the results of the expand.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="adda4181ccd15beb52c39f5e24adbb25b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a8fa9094bebe1256a7be935a5ede87a64">Xapian::docid</a>&#160;</td>
          <td class="paramname"><em>did</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get terms which match a given document, by document id. </p>
<p>This method returns the terms in the current query which match the given document.</p>
<p>It is possible for the document to have been removed from the database between the time it is returned in an <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>, and the time that this call is made. If possible, you should specify an <a class="el" href="classXapian_1_1MSetIterator.html" title="An iterator pointing to items in an MSet. ">MSetIterator</a> instead of a <a class="el" href="namespaceXapian.html#a8fa9094bebe1256a7be935a5ede87a64" title="A unique identifier for a document. ">Xapian::docid</a>, since this will enable database backends with suitable support to prevent this occurring.</p>
<p>Note that a query does not need to have been run in order to make this call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">did</td><td>The document id for which to retrieve the matching terms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database. ">Xapian::DocNotFoundError</a></td><td>The document specified could not be found in the database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4d531a494be857ae09c831480ff651d7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1TermIterator.html">TermIterator</a> Xapian::Enquire::get_matching_terms_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MSetIterator.html">MSetIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>it</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get terms which match a given document, by match set item. </p>
<p>This method returns the terms in the current query which match the given document.</p>
<p>If the underlying database has suitable support, using this call (rather than passing a <a class="el" href="namespaceXapian.html#a8fa9094bebe1256a7be935a5ede87a64" title="A unique identifier for a document. ">Xapian::docid</a>) will enable the system to ensure that the correct data is returned, and that the document has not been deleted or changed since the query was performed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">it</td><td>The iterator for which to retrieve the matching terms.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An iterator returning the terms which match the document. The terms will be returned (as far as this makes any sense) in the same order as the terms in the query. Terms will not occur more than once, even if they do in the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
    <tr><td class="paramname"><a class="el" href="classXapian_1_1DocNotFoundError.html" title="Indicates an attempt to access a document not present in the database. ">Xapian::DocNotFoundError</a></td><td>The document specified could not be found in the database. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1fc149dc9c58bc962ce9e4372c863185"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>checkatleast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>mdecider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>matchspy</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (a portion of) the match set for the current query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases. ">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a>'s match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td class="paramname">checkatleast</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td class="paramname">mdecider</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. </td></tr>
    <tr><td class="paramname">matchspy</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>The matchspy parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies. ">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#a43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy. ">add_matchspy()</a> method instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aedb5fb761acc0bb2249bec375883a093"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>checkatleast</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&#160;</td>
          <td class="paramname"><em>omrset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>mdecider</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get (a portion of) the match set for the current query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases. ">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a>'s match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td class="paramname">checkatleast</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td class="paramname">mdecider</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. </td></tr>
    <tr><td class="paramname">matchspy</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>The matchspy parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies. ">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#a43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy. ">add_matchspy()</a> method instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad53aba9cb5b62d14dce5395f568c050f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXapian_1_1MSet.html">MSet</a> Xapian::Enquire::get_mset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>maxitems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1RSet.html">RSet</a> *&#160;</td>
          <td class="paramname"><em>omrset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1MatchDecider.html">MatchDecider</a> *&#160;</td>
          <td class="paramname"><em>mdecider</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get (a portion of) the match set for the current query. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">first</td><td>the first item in the result set to return. A value of zero corresponds to the first item returned being that with the highest score. A value of 10 corresponds to the first 10 items being ignored, and the returned items starting at the eleventh. </td></tr>
    <tr><td class="paramname">maxitems</td><td>the maximum number of items to return. If you want all matches, then you can pass the result of calling get_doccount() on the <a class="el" href="classXapian_1_1Database.html" title="This class is used to access a database, or a group of databases. ">Database</a> object (though if you are doing this so you can filter results, you are likely to get much better performance by using <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a>'s match-time filtering features instead). You can pass 0 for maxitems which will give you an empty <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a> with valid statistics (such as get_matches_estimated()) calculated without looking at any postings, which is very quick, but means the estimates may be more approximate and the bounds may be much looser. </td></tr>
    <tr><td class="paramname">checkatleast</td><td>the minimum number of items to check. Because the matcher optimises, it won't consider every document which might match, so the total number of matches is estimated. Setting checkatleast forces it to consider at least this many matches and so allows for reliable paging links. </td></tr>
    <tr><td class="paramname">omrset</td><td>the relevance set to use when performing the query. </td></tr>
    <tr><td class="paramname">mdecider</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. </td></tr>
    <tr><td class="paramname">matchspy</td><td>a decision functor to use to decide whether a given document should be put in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. The matchspy is applied to every document which is a potential candidate for the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>, so if there are checkatleast or more such documents, the matchspy will see at least checkatleast. The mdecider is assumed to be a relatively expensive test so may be applied in a lazier fashion.</td></tr>
  </table>
  </dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000001">Deprecated:</a></b></dt><dd>The matchspy parameter is deprecated - use the newer <a class="el" href="classXapian_1_1MatchSpy.html" title="Abstract base class for match spies. ">MatchSpy</a> class and <a class="el" href="classXapian_1_1Enquire.html#a43b54489c53d26a98d3fde3f1d3aa14f" title="Add a matchspy. ">add_matchspy()</a> method instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>A <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">Xapian::MSet</a> object containing the results of the query.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>See class documentation. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="add445bf19315638cccbb6418e2ae0d42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a>&amp; Xapian::Enquire::get_query </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the query which has been set. </p>
<p>This is only valid after <a class="el" href="classXapian_1_1Enquire.html#a1148d960120662e5543e2a2b12620318" title="Set the query to run. ">set_query()</a> has been called.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname"><a class="el" href="classXapian_1_1InvalidArgumentError.html" title="InvalidArgumentError indicates an invalid parameter value was passed to the API. ">Xapian::InvalidArgumentError</a></td><td>will be thrown if query has not yet been set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a117ee547f5908e952e2e72d5a986d3bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_collapse_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>collapse_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a7f30aa95f0c42b117dafaf66ba24241d">Xapian::doccount</a>&#160;</td>
          <td class="paramname"><em>collapse_max</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the collapse key to use for queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">collapse_key</td><td>value number to collapse on - at most one <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a> entry with each particular value will be returned (default is <a class="el" href="namespaceXapian.html#a0a75ef120e641c77f703e60f595ffda2" title="Reserved value to indicate &quot;no valueno&quot;. ">Xapian::BAD_VALUENO</a> which means no collapsing).</td></tr>
    <tr><td class="paramname">collapse_max</td><td>Max number of items with the same key to leave after collapsing (default 1).</td></tr>
  </table>
  </dd>
</dl>
<p>The <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a> returned by <a class="el" href="classXapian_1_1Enquire.html#a1fc149dc9c58bc962ce9e4372c863185" title="Get (a portion of) the match set for the current query. ">get_mset()</a> will have only the "best" (at most) <em>collapse_max</em> entries with each particular value of <em>collapse_key</em> ("best" being highest ranked - i.e. highest weight or highest sorting key).</p>
<p>An example use might be to create a value for each document containing an MD5 hash of the document contents. Then duplicate documents from different sources can be eliminated at search time by collapsing with <em>collapse_max</em> = 1 (it's better to eliminate duplicates at index time, but this may not be always be possible - for example the search may be over more than one <a class="el" href="namespaceXapian.html" title="The Xapian namespace contains public interfaces for the Xapian library. ">Xapian</a> database).</p>
<p>Another use is to group matches in a particular category (e.g. you might collapse a mailing list search on the Subject: so that there's only one result per discussion thread). In this case you can use get_collapse_count() to give the user some idea how many other results there are. And if you index the Subject: as a boolean term as well as putting it in a value, you can offer a link to a non-collapsed search restricted to that thread using a boolean filter. </p>

</div>
</div>
<a class="anchor" id="adadaa8401e40ab4cec090bc1541a11b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_cutoff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a22ea0a80c58a2047dd929621b75ed9a2">Xapian::percent</a>&#160;</td>
          <td class="paramname"><em>percent_cutoff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#acac12803afc9e24ee5141c119acb8884">Xapian::weight</a>&#160;</td>
          <td class="paramname"><em>weight_cutoff</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the percentage and/or weight cutoffs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">percent_cutoff</td><td>Minimum percentage score for returned documents. If a document has a lower percentage score than this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. If your intention is to return only matches which contain all the terms in the query, then it's more efficient to use <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bab99aad2dfc85eccc56163bc65eb0fdda" title="Return iff both subqueries are satisfied. ">Xapian::Query::OP_AND</a> instead of <a class="el" href="classXapian_1_1Query.html#a7e7b6b8ad0c915c2364578dfaaf6100bac50e54f3dd9dc59dab7daa2c50cf631b" title="Return if either subquery is satisfied. ">Xapian::Query::OP_OR</a> in the query than to use set_cutoff(100). (default 0 =&gt; no percentage cut-off). </td></tr>
    <tr><td class="paramname">weight_cutoff</td><td>Minimum weight for a document to be returned. If a document has a lower score that this, it will not appear in the <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. It is usually only possible to choose an appropriate weight for cutoff based on the results of a previous run of the same query; this is thus mainly useful for alerting operations. The other potential use is with a user specified weighting scheme. (default 0 =&gt; no weight cut-off). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abbf7ff734ff6adcb301e493f6eed803b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_docid_order </td>
          <td>(</td>
          <td class="paramtype">docid_order&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the direction in which documents are ordered by document id in the returned <a class="el" href="classXapian_1_1MSet.html" title="A match set (MSet). ">MSet</a>. </p>
<p>This order only has an effect on documents which would otherwise have equal rank. For a weighted probabilistic match with no sort value, this means documents with equal weight. For a boolean match, with no sort value, this means all documents. And if a sort value is used, this means documents with equal sort value (and also equal weight if ordering on relevance after the sort).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">order</td><td>This can be:<ul>
<li>Xapian::Enquire::ASCENDING docids sort in ascending order (default)</li>
<li>Xapian::Enquire::DESCENDING docids sort in descending order</li>
<li><p class="startli">Xapian::Enquire::DONT_CARE docids sort in whatever order is most efficient for the backend</p>
<p class="startli">Note: If you add documents in strict date order, then a boolean search - i.e. set_weighting_scheme(<a class="el" href="classXapian_1_1BoolWeight.html" title="Class implementing a &quot;boolean&quot; weighting scheme. ">Xapian::BoolWeight()</a>) - with set_docid_order(Xapian::Enquire::DESCENDING) is an efficient way to perform "sort by date, newest first", and with set_docid_order(Xapian::Enquire::ASCENDING) a very efficient way to perform "sort by date, oldest first". </p>
</li>
</ul>
</td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1148d960120662e5543e2a2b12620318"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_query </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Query.html">Xapian::Query</a> &amp;&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a72b5a76dd8cfb7b251fe7986e86390cb">Xapian::termcount</a>&#160;</td>
          <td class="paramname"><em>qlen</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the query to run. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">query</td><td>the new query to run. </td></tr>
    <tr><td class="paramname">qlen</td><td>the query length to use in weight calculations - by default the sum of the wqf of all terms is used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a0bcb7086d8633fc035c6e5d094e45d39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by key generated from values only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a562beac4843f310dbdc61fdd33209be4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_key_then_relevance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by keys generated from values, then by relevance for documents with identical keys. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a80a33a28791c05167204706c1a9d986b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance only. </p>
<p>This is the default. </p>

</div>
</div>
<a class="anchor" id="ac64b07e06a24519baf1c495d0edcd0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classXapian_1_1KeyMaker.html">Xapian::KeyMaker</a> *&#160;</td>
          <td class="paramname"><em>sorter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance, then by keys generated from values. </p>
<p>Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only. ">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sorter</td><td>The functor to use for generating keys.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order of the generated keys. Beware that in 1.2.16 and earlier, the sense of this parameter was incorrectly inverted and inconsistent with the other set_sort_by_... methods. This was fixed in 1.2.17, so make that version a minimum requirement if this detail matters to your application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a5a495760d5edc479385b14b463affbff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_relevance_then_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by relevance then value. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order. ">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<p>Note that with the default BM25 weighting scheme parameters, non-identical documents will rarely have the same weight, so this setting will give very similar results to <a class="el" href="classXapian_1_1Enquire.html#a80a33a28791c05167204706c1a9d986b" title="Set the sorting to be by relevance only. ">set_sort_by_relevance()</a>. It becomes more useful with particular BM25 parameter settings (e.g. BM25Weight(1,0,1,0,0)) or custom weighting schemes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order of sort_key. Beware that in 1.2.16 and earlier, the sense of this parameter was incorrectly inverted and inconsistent with the other set_sort_by_... methods. This was fixed in 1.2.17, so make that version a minimum requirement if this detail matters to your application. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab10384fabd51eebd8174f916563e3f7a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by value only. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order. ">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa921b3c9386fbe2ddfd7dbbf130f9391"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_sort_by_value_then_relevance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceXapian.html#a94a899651fa920c72ffa9635bde630ea">Xapian::valueno</a>&#160;</td>
          <td class="paramname"><em>sort_key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the sorting to be by value, then by relevance for documents with the same value. </p>
<p>Note that sorting by values uses a string comparison, so to use this to sort by a numeric value you'll need to store the numeric values in a manner which sorts appropriately. For example, you could use <a class="el" href="namespaceXapian.html#a29a741b4cda98e10ed5f2fc784039065" title="Convert a floating point number to a string, preserving sort order. ">Xapian::sortable_serialise()</a> (which works for floating point numbers as well as integers), or store numbers padded with leading zeros or spaces, or with the number of digits prepended.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">sort_key</td><td>value number to sort on.</td></tr>
    <tr><td class="paramname">reverse</td><td>If true, reverses the sort order. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad5c72e6f34c5c2da5f0b8c79736704ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Xapian::Enquire::set_weighting_scheme </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classXapian_1_1Weight.html">Weight</a> &amp;&#160;</td>
          <td class="paramname"><em>weight_</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the weighting scheme to use for queries. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">weight_</td><td>the new weighting scheme. If no weighting scheme is specified, the default is BM25 with the default parameters. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>xapian/<a class="el" href="enquire_8h.html">enquire.h</a></li>
</ul>
</div><!-- contents -->
<hr>
<address><small>
Documentation for Xapian (version 1.2.17).<br>
Generated on Wed Jan 29 2014 by
<a href="http://www.doxygen.org/">Doxygen 1.8.5</a>.
</small></address>
</body>
</html>
